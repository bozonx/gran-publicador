// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
}

model User {
  id String @id @default(uuid())

  fullName         String?  @map("full_name")
  // Telegram username without @ symbol
  telegramUsername String?  @map("telegram_username")
  avatarUrl        String?  @map("avatar_url")
  // Unique Telegram user ID for authentication
  telegramId       BigInt?  @unique @map("telegram_id")
  // System administrator flag for elevated permissions
  isAdmin          Boolean  @default(false) @map("is_admin")
  // Hashed refresh token for JWT pair auth
  hashedRefreshToken String? @map("hashed_refresh_token")
  // User ban status
  isBanned         Boolean  @default(false) @map("is_banned")
  banReason        String?  @map("ban_reason")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  // Timestamp when user was soft-deleted
  deletedAt        DateTime? @map("deleted_at")
  // User preferences stored as JSON
  preferences      Json

  ownedProjects  Project[]       @relation("ProjectOwner")
  projectMembers ProjectMember[]
  publications       Publication[] @relation("PublicationCreator")
  apiTokens      ApiToken[]
  notifications  Notification[]
  llmPromptTemplates LlmPromptTemplate[]
  authorSignatures AuthorSignature[]

  @@index([telegramUsername])
  @@map("users")
}

model ApiToken {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  // User-friendly name for the token
  name            String
  // Hashed token for authentication (bcrypt/argon2)
  hashedToken     String    @unique @map("hashed_token")
  // Encrypted token for one-time display to user
  encryptedToken  String    @map("encrypted_token")
  // If true, token has access to all user's projects (including future ones)
  allProjects     Boolean   @default(false) @map("all_projects")
  // Last time this token was used for authentication
  lastUsedAt      DateTime? @map("last_used_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  projects ApiTokenProject[]

  @@index([userId])
  @@map("api_tokens")
}

model Project {
  id          String    @id @default(uuid())
  name        String
  description String?
  ownerId     String    @map("owner_id")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  // Timestamp when project was archived
  archivedAt  DateTime? @map("archived_at")
  // User ID who archived the project
  archivedBy  String?   @map("archived_by")
  // Project preferences stored as JSON
  preferences Json

  owner        User            @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members      ProjectMember[]
  channels     Channel[]
  publications Publication[]
  llmPromptTemplates LlmPromptTemplate[]
  apiTokens    ApiTokenProject[]
  roles        Role[]

  @@map("projects")
}

model Role {
  id          String   @id @default(uuid())
  projectId   String   @map("project_id")
  name        String
  description String?
  // System role (ADMIN, EDITOR, VIEWER) or custom role
  isSystem    Boolean  @default(false) @map("is_system")
  // System role type for identification (ADMIN, EDITOR, VIEWER)
  systemType  String?  @map("system_type")
  // Role permissions stored as JSON
  permissions Json
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  project Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  members ProjectMember[]

  @@unique([projectId, name])
  @@index([projectId])
  @@map("roles")
}

model ApiTokenProject {
  id         String   @id @default(uuid())
  apiTokenId String   @map("api_token_id")
  projectId  String   @map("project_id")
  createdAt  DateTime @default(now()) @map("created_at")

  apiToken ApiToken @relation(fields: [apiTokenId], references: [id], onDelete: Cascade)
  project  Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([apiTokenId, projectId])
  @@index([apiTokenId])
  @@index([projectId])
  @@map("api_token_projects")
}

model ProjectMember {
  id        String   @id @default(uuid())
  projectId String   @map("project_id")
  userId    String   @map("user_id")
  roleId    String   @map("role_id")
  createdAt DateTime @default(now()) @map("created_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  role    Role    @relation(fields: [roleId], references: [id], onDelete: Restrict)

  @@unique([projectId, userId])
  @@index([roleId])
  @@map("project_members")
}

model Channel {
  id                String      @id @default(uuid())
  projectId         String      @map("project_id")
  // Social media platform type (TELEGRAM, INSTAGRAM, etc.)
  socialMedia       SocialMedia @map("social_media")
  name              String
  description       String?
  // Platform-specific channel identifier (e.g., @channel_name, channel_id)
  channelIdentifier String      @map("channel_identifier")
  // Channel language in format like ru-RU, en-US, etc.
  language          String
  // Encrypted credentials for channel access
  credentials       Json
  // Channel preferences
  preferences       Json
  // Tags for navigation and publication orientation
  tags              String?

  // Whether channel is active for posting
  isActive          Boolean     @default(true) @map("is_active")
  createdAt         DateTime    @default(now()) @map("created_at")
  updatedAt         DateTime    @updatedAt @map("updated_at")
  // Timestamp when channel was archived
  archivedAt        DateTime?   @map("archived_at")
  // User ID who archived the channel
  archivedBy        String?     @map("archived_by")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  posts   Post[]
  authorSignatures AuthorSignature[]

  @@index([projectId])
  @@map("channels")
}

model Publication {
  id                 String  @id @default(uuid())
  projectId          String? @map("project_id")
  // ID for linking translations of the same content
  translationGroupId String? @map("translation_group_id")

  // User who created the publication (nullable for system-generated)
  createdBy  String?   @map("created_by")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @default(now()) @map("updated_at")
  // Timestamp when publication was archived
  archivedAt DateTime? @map("archived_at")
  // User ID who archived the publication
  archivedBy String?   @map("archived_by")
  // When the publication is scheduled to be published
  scheduledAt   DateTime? @map("scheduled_at")
  // Timestamp when processing started (to detect timeouts)
  processingStartedAt DateTime? @map("processing_started_at")

  // Type of post (POST, ARTICLE, VIDEO, etc.) - master type for distribution
  postType      PostType   @default(POST) @map("post_type")
  // Language of the publication (ru-RU, en-US, etc.)
  language      String     @default("en-US")
  // Publication status (user can select: DRAFT, READY; system sets: SCHEDULED, PROCESSING, PUBLISHED, PARTIAL, FAILED, EXPIRED)
  status        PublicationStatus @default(DRAFT)
  // Title for articles and social media posts where title is required. Even if not required, it's recommended to fill it for easier post identification in Gran Publicador
  title         String?
  // Description for SEO purposes and social media. Can be used when publishing to websites
  description   String?
  // Main content: post text, article body, or description for video/audio/documents. Should be filled for any publication type
  content       String?
  // Author's commentary for the news (published along with the content)
  authorComment String?    @map("author_comment")
  tags          String?
  // Additional metadata stored as JSON
  meta          Json
  // Content date set by the author (e.g., article date, event date). Not the publication/posting date
  postDate      DateTime?  @map("post_date")
  // Internal note for author's reference only. Never published to social media
  note          String?

  // Additional source texts collected via Telegram bot or other sources
  // Format: [{ content, order, source? }]
  // source format: "url:<URL>" | "telegram:<chatId>,<messageId>" | "manual"
  sourceTexts Json @map("source_texts")

  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator User?    @relation("PublicationCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  posts   Post[]
  media   PublicationMedia[]

  @@index([translationGroupId])
  @@index([projectId, status])
  @@index([projectId, createdAt])
  @@index([projectId, scheduledAt])
  @@index([createdBy, projectId, archivedAt])
  @@map("publications")
}

model Post {
  id            String    @id @default(uuid())
  // Link to parent publication
  publicationId String    @map("publication_id")
  channelId     String    @map("channel_id")
  // Social media platform type stored as string for flexibility
  socialMedia   String    @map("social_media")
  // Tags specific to this channel (can override publication tags)
  tags          String?
  // Post status for tracking publication success (PENDING, FAILED, PUBLISHED)
  // Note: Status is managed by the system only, not manually editable
  status        PostStatus @default(PENDING)
  // Error message if post failed
  errorMessage  String?    @map("error_message")
  // Data received after publication (usually url or message id). Not editable by user.
  meta          Json
  template      Json?
  // Overwrite of publication content for this specific post
  content       String?
  // Platform-specific options (e.g., disableNotification for Telegram)
  platformOptions Json? @map("platform_options")
  // Author signature content (markdown text copied from signature template at post creation)
  authorSignature String? @map("author_signature") @db.Text

  // Overwrite of publication scheduledAt
  scheduledAt   DateTime? @map("scheduled_at")
  // Actual timestamp when post was published to platform. Set by the publishing service only.
  publishedAt   DateTime? @map("published_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @default(now()) @map("updated_at")

  publication Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  channel     Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@index([status, scheduledAt])
  @@index([channelId, createdAt])
  @@index([publicationId])
  @@map("posts")
}

model AuthorSignature {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  channelId String   @map("channel_id")
  
  // Name of the signature for UI selection
  name      String
  // Markdown content of the signature
  content   String
  // Is this the default signature for the user on this channel
  isDefault Boolean  @default(false) @map("is_default")
  // Display order
  order       Int      @default(0)
  
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  
  @@unique([userId, channelId, name])
  @@index([userId, channelId])
  @@index([channelId])
  @@map("author_signatures")
}

model Media {
  id          String      @id @default(uuid())
  type        MediaType
  storageType StorageType @map("storage_type")
  storagePath String      @map("storage_path")
  filename    String?
  alt         String?
  description String?
  mimeType    String?     @map("mime_type")
  sizeBytes   BigInt?     @map("size_bytes")
  // Metadata stored as JSON. For StorageType.TELEGRAM, contains:
  // { telegram: { thumbnailFileId: string } }
  meta        Json
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  publicationMedia PublicationMedia[]

  @@index([type])
  @@index([storageType])
  @@map("media")
}

model PublicationMedia {
  id             String   @id @default(uuid())
  publicationId  String   @map("publication_id")
  mediaId        String?  @map("media_id")
  order          Int      @default(0)
  hasSpoiler     Boolean  @default(false) @map("has_spoiler")
  createdAt      DateTime @default(now()) @map("created_at")

  publication Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  media       Media?      @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@index([publicationId])
  @@index([mediaId])
  @@map("publication_media")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      NotificationType
  title     String
  message   String
  // JSON metadata: { publicationId?, postId?, channelId?, projectId? }
  meta      Json
  readAt    DateTime? @map("read_at")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([userId, createdAt])
  @@map("notifications")
}

model LlmPromptTemplate {
  id          String   @id @default(uuid())
  // User ID for personal templates, null for project templates
  userId      String?  @map("user_id")
  // Project ID for project templates, null for personal templates
  projectId   String?  @map("project_id")
  
  name        String
  description String?
  // The actual prompt template text
  prompt      String
  // Display order for UI
  order       Int      @default(0)
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  user    User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([projectId])
  @@map("llm_prompt_templates")
}


enum SocialMedia {
  TELEGRAM
  VK
  YOUTUBE
  TIKTOK
  FACEBOOK
  SITE
}

enum PostType {
  POST
  ARTICLE
  // News post, usually from automatic news collector
  NEWS
  // Long horisontal video
  VIDEO
  // Short vertical video
  SHORT
  STORY
}

// Publication status enum - tracks the lifecycle of a publication
enum PublicationStatus {
  DRAFT      // Draft, may be partially filled or incomplete
  READY      // Ready post, not published (prepared in advance or removed from SCHEDULED)
  SCHEDULED  // Scheduled for future publication, date is set but not yet reached
  PROCESSING // Selected by publishing service and being processed
  PUBLISHED  // All posts successfully published
  PARTIAL    // Some posts published, some failed
  FAILED     // All posts failed to publish
  EXPIRED    // Publication missed the publishing service selection window
}

// Post status enum - tracks individual post publication status
// Note: Post status is managed by the system only, not manually editable
enum PostStatus {
  PENDING    // Post has not yet been attempted to publish
  FAILED     // Publication failed
  PUBLISHED  // Post was successfully published to the channel
}

enum NotificationType {
  PUBLICATION_FAILED     // Issue during publication (failed/partial)
  PROJECT_INVITE        // Invitation to a project
  SYSTEM                // System notification
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
}

// Storage type enum - defines where the media file is physically stored
enum StorageType {
  FS       // File system (local or mounted S3)
  TELEGRAM // Telegram servers (not stored locally)
}
