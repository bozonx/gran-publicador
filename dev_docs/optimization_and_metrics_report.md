# Отчет по оптимизации и метрикам (Optimization & Metrics Report)

## ✅ Что было сделано (Quick Wins)

В рамках задачи "быстрой реализации" были выполнены следующие изменения:

### 1. Добавление детализации ошибок
В схему базы данных (`prisma/schema.prisma`) были добавлены поля `errorMessage` для моделей `Post` и `Publication`.
*   **Зачем**: Ранее при статусе `FAILED` было невозможно понять причину сбоя, так как сохранялся только статус.
*   **Реализация**:
    *   Добавлен столбец `errorMessage` (String, nullable).
    *   Обновлены сервисы `PostsService` и `PublicationsService`, чтобы они принимали и сохраняли сообщение об ошибке при обновлении сущности.
    *   Выполнена миграция БД: `20260105212158_add_error_message_fields`.

## ⏭️ Что осталось сделать (Remaining Tasks)

Следующие задачи требуют более глубокого вмешательства в архитектуру или сложные рефакторинги, поэтому они вынесены в отдельный список на будущее.

### 1. Оптимизация списка проектов (`ProjectsService.findAllForUser`)
**Проблема**: Метод загружает **все каналы** каждого проекта (включая их настройки) только для того, чтобы:
1.  Посчитать количество постов со статусом `FAILED`.
2.  Определить, является ли канал "заброшенным" (stale) на основе даты последнего поста.

При большом количестве каналов (сотни и тысячи) это приведет к значительной задержке и расходу памяти.

**Решение (TODO)**:
*   Переписать запрос на использование `prisma.groupBy` или Raw SQL.
*   Избежать выборки массива `channels` целиком, если он не нужен клиенту для отображения (клиенту обычно нужны только счетчики).

### 2. Оптимизация определения "Заброшенных каналов" (Stale Channels)
**Проблема**: Сейчас логика определения "stale" (например, нет постов > 7 дней) выполняется в коде приложения (in-memory) после выгрузки всех каналов.
```typescript
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
```
Это не позволяет эффективно фильтровать или сортировать по этому признаку на уровне базы данных.

**Решение (TODO)**:
*   **Вариант А (Простой)**: Добавить поле `lastPostAt` в модель `Channel` и обновлять его при каждом успешном посте. Тогда поиск заброшенных каналов станет простым условием: `WHERE lastPostAt < NOW - 7 DAYS`.
*   **Вариант Б (Raw SQL)**: Использовать сложный SQL запрос с JOIN к таблице `posts` для вычисления даты на лету (медленнее, чем Вариант А).

### 3. Производительность JSON полей
**Проблема**: Поля `preferences` и `credentials` хранятся как строки и парсятся через `JSON.parse` в каждом цикле `map`.
**Решение (TODO)**:
*   В методах, где эти данные не требуются фронтенду (например, списки), исключить их из `select`.

## Резюме
Критический недостаток с отсутствием текстов ошибок устранен. Основной точкой роста производительности является рефакторинг работы со списком каналов внутри проектов.
