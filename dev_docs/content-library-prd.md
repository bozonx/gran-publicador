# PRD: Библиотека контента (Content Library)

## 1. Контекст и цель
В продукте пользователи работают с большим объёмом сырого контента из разных источников:

- посты из соцсетей (копии/черновики)
- новости из микросервиса новостей
- репосты/пересланные сообщения из Telegram
- собственные заметки, наброски, фрагменты текстов
- часто используемые медиа (логотипы, обложки, видео-вставки и т.п.)

Нужна единая «библиотека контента», где пользователь может:

- хранить сырьё и медиа
- быстро искать по тексту и по описанию медиа
- собирать из нескольких единиц финальные публикации
- отдавать выбранные элементы в LLM для объединения/редактирования

## 2. Problem Statement
Сейчас контент живёт разрозненно: часть в публикациях (`Publication`), часть в медиа (`Media`), часть приходит из внешних источников.

Проблемы:

- сложно переиспользовать медиа (логотипы/шаблонные изображения)
- сложно искать «кусочки» контента по смыслу/описанию
- нет устойчивой модели «сырого контента», из которого потом собирается `Publication`

## 3. Objectives / KPI (ориентиры)
- Сократить время поиска нужного материала пользователем.
- Упростить повторное использование медиа.
- Снизить число дублей одинаковых медиа/набросков.

Метрики (позже, когда появится аналитика):

- медианное время от «открытия библиотеки» до «добавления в публикацию»
- доля публикаций, собранных из библиотеки
- доля переиспользованных `Media` (используется более 1 раза)

## 4. Non-goals (не входит в MVP)
- Полноценное управление правами доступа уровня «поделиться публично по ссылке».
- Автоматическая модерация/антиплагиат.
- Полноценный AI-ассистент, который сам предлагает контент (можно добавить позже).

## 5. Основные пользовательские сценарии (User Stories)

### 5.1 Добавление
- Пользователь добавляет элемент контента вручную:
  - текст(ы) + медиа(файлы)
  - только текст(ы)
  - только медиа
- Пользователь импортирует контент из внешнего источника:
  - новость из микросервиса новостей
  - Telegram forward/repost
  - ссылка на пост/страницу (на первом этапе можно как «source url + текст»)

### 5.2 Поиск и навигация
- Поиск по тексту (название, текстовые блоки, заметки).
- Поиск по метаданным (тип, теги, источник, дата добавления).
- Поиск по описанию медиа (alt/description) и извлечённым описаниям (в будущем).

### 5.3 Сборка публикации
- Пользователь выбирает 1..N элементов из библиотеки и:
  - создаёт `Publication`-черновик
  - прикрепляет выбранные медиа
  - копирует/объединяет тексты в `Publication.content` или `Publication.sourceTexts`

### 5.4 LLM-объединение
- Пользователь выбирает несколько элементов и отправляет в LLM:
  - «сделай единый пост»
  - «сделай 3 варианта»
  - «суммаризируй»

Результат сохраняется как новый элемент библиотеки и/или заполняет `Publication`.

## 6. Термины и сущности (Domain Model)

### 6.1 Предлагаемые сущности (на уровне домена)
- **ContentItem** — единица сырого контента в библиотеке.
- **ContentText** — один текстовый блок внутри ContentItem.
- **ContentItemMedia** — связь ContentItem с существующей таблицей `Media`.
- **ContentSource** (опционально в MVP) — ссылка на источник (news/telegram/url/manual).

### 6.2 Инварианты
- У `ContentItem` должно быть:
  - либо минимум один `ContentText`,
  - либо минимум один связанный `Media`.

### 6.3 Сопоставление с текущими сущностями
- `Publication` остаётся сущностью для «готовящегося/готового к публикации контента».
- `Media` уже существует и должна переиспользоваться.
- `PublicationMedia` остаётся связкой публикации с медиа.

Идея: библиотека не должна «ломать» текущий flow публикаций; она добавляет слой «сырья», из которого создаются/заполняются `Publication`.

## 7. Хранение и поиск

### 7.1 Где хранить данные библиотеки
Рекомендуемый MVP:

- **PostgreSQL (текущая БД)** для:
  - метаданных `ContentItem`
  - текстов (`ContentText`)
  - связей с `Media`
  - простого фильтрационного поиска

### 7.2 Полнотекстовый поиск (MVP)
- Использовать поиск `ILIKE/contains` по ключевым полям (быстрый старт).
- Следующая итерация: Postgres FTS (`tsvector` + индекс) по агрегированному тексту.

### 7.3 Векторный поиск (позже)
Варианты:

1) **pgvector в текущем Postgres**
- Плюсы:
  - меньше инфраструктуры
  - транзакционная целостность
  - проще деплой/бэкапы
- Минусы:
  - нагрузка на основную БД

2) **Отдельная векторная БД** (например, Qdrant)
- Плюсы:
  - лучше масштабируется под поиск
  - отдельное хранение эмбеддингов/индексов
- Минусы:
  - отдельная инфраструктура, синхронизация, eventual consistency

Рекомендация: начать с Postgres (без вектора), затем добавить **pgvector**; переход на отдельную векторную БД имеет смысл, когда:

- большие объёмы контента
- нужны сложные гибридные запросы
- заметная нагрузка на основную БД

### 7.4 Поиск по описанию медиа
MVP:

- ручное поле `Media.description` / `Media.alt`
- поиск по этим полям

Позже:

- автогенерация описаний (image captioning) и сохранение как отдельные `ContentText` типа `caption` или как `Media.meta`

## 8. Интеграции и импорт

### 8.1 Новости
- При импорте новости создавать `ContentItem` с:
  - `ContentSource.type = news`
  - `externalId = newsItemId`
  - 1..N `ContentText` (title/body/summary)

### 8.2 Telegram
- При импорте сообщений создавать `ContentItem` с:
  - `ContentSource.type = telegram`
  - ссылкой на chatId/messageId
  - медиа, если есть (через `Media` с `StorageType.TELEGRAM`)

## 9. Права доступа и скоуп
Требуется поддержать два скоупа, аналогично публикациям:

- **personal** (user-level)
- **project** (project-level)

Требование:

- пользователь видит личную библиотеку
- пользователь видит библиотеку проектов, где у него есть доступ

## 10. API / UX (уровень требований)

### 10.1 Минимальный набор функций (MVP)
- CRUD `ContentItem`
- прикрепление существующего `Media` к `ContentItem`
- загрузка нового `Media` и привязка к `ContentItem`
- поиск (текстовый) + фильтры
- «создать публикацию из выбранного контента»

### 10.2 UX-набросок
- Экран «Библиотека»:
  - поиск
  - фильтры
  - список карточек (текст превью + превью медиа)
  - мультивыбор → действия:
    - создать публикацию
    - отправить в LLM

## 11. Итерации

### Итерация 1 (MVP)
- Модель `ContentItem` + тексты + связь с `Media`
- простой поиск (contains)
- ручные теги
- создание `Publication` из выбранных элементов

### Итерация 2
- Postgres FTS
- импорт из новостей/telegram в библиотеку (если сейчас импорт идёт напрямую в `Publication`)

### Итерация 3
- эмбеддинги + `pgvector` + гибридный поиск
- автогенерация описаний изображений/видео

## 12. Риски и вопросы
- Дедупликация медиа (хэши/чексуммы): риск лавины дублей.
- Права доступа для `Media`: сейчас доступ проверяется через `publicationMedia`; библиотека добавит новый путь доступа.
- Согласование модели `Publication.sourceTexts`: возможно часть «сырья» логичнее хранить в библиотеке, а в публикацию копировать только нужное.

## 13. Предлагаемый нейминг
Рекомендуемый нейминг (англ. в коде, рус. в UI):

- `ContentItem` — элемент библиотеки
- `ContentText` — текстовый блок
- `ContentItemMedia` — связка с `Media`
- `ContentSource` — источник

Альтернативы:

- `LibraryItem` (слишком общий)
- `Asset` (чаще про медиа, а не текст)
- `Snippet` (скорее «кусок текста», хуже для медиа)

## 14. Ответы на ключевые архитектурные вопросы (конспект)
- **Где хранить**: начать в текущем Postgres; векторный поиск — позже через `pgvector`, отдельная векторная БД только при росте.
- **Медиа**: переиспользовать существующую таблицу `Media`, добавить новую связь `ContentItemMedia`.
- **Как назвать сущности**: `ContentItem`/`ContentText`/`ContentItemMedia`/`ContentSource`.
